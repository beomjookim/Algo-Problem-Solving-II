# 회의실 배정


## 브레인 스토밍

딱 보면 그리디 알고리즘으로 푸는 문제라는 게 자명하다. 시작 시각이 가장 먼저인 녀석과, 끝 시각이 가장 먼저인 녀석 중 끝 시각이 가장 먼저인 녀석을 골라야한다. 그런데 끝 시각이 가장 먼저인 녀석들 중에서는 시작 시각이 가장 먼저인 녀석을 고르는 것이 좋다. 이 부분을 생각하지 못했다. 문제의 조건에, 끝시각과 시작시각이 같다면 터치를 하면서 그 다음 회의를 시작할 수 있다고 되어 있는데, 만약 2에 시작해서 2에 끝나는 녀석이 있다면 1에 시작해서 2에 시작하는 녀석 뒤에 딱 붙어서 한 자리 할 수 있기 때문이다. 즉 1 2, 2 2 이렇게 되어 있다면 기본적으로는 시작 시각 기준 오름차순 정렬이 되어 있어야 저 부분에서 두 개가 추가 될 것이기 때문이다. 결과적으로는, 시작 시각 기준으로 오름차순 정렬을 하고, 끝 시각 기준으로 오름차순 정렬을 한 번 더 해준 후, 현재 들어가 있는 회의의 끝 시각보다 시작 시각이 같거나 이후인 경우마다 카운트를 해주고 끝 시각을 갱신해주는 것을 반복해주면 된다... 말이 너무 길지만 이해하고 나면 어렵지 않은 알고리즘이다.

```python
time.sort(key = lambda x: x[0])
time.sort(key = lambda x: x[1])

# 위의 코드와 아래 코드는 완전히 동일하다. 가장 나중에 정렬되어야 하는 기준이 가장 앞으로 오는 특이한 구조.

time.sort(key= lambda x: (x[1], x[0]))
```

추가로, import sys 후 sys.stdin.readlin()을 해주는 것과 똑같은 자리에 input()을 해주는 것은, 다른 모든 부분이 똑같은 코드에서도 10배 정도의 실행속도 차이가 났다. 그래서 굳이 sys를 써주는가보다. 이 둘의 차이는, 간단히 말하면 input()은 prompt message를 받을 여지가 있고, 또 개행 문자를 삭제시켜서 리턴하는 등의 부가적인 전처리를 해주기 때문에 훨씬 더 시간이 많이 걸린다. 파이썬으로 코테를 준비하면서 굳이 input()을 쓸 필요는 없어보인다.



## 코드

```python
import sys

n, sessions = int(sys.stdin.readline()), []

for _ in range(n):
    s, e = map(int, sys.stdin.readline().split())
    sessions.append([s, e])
    
sessions.sort(key = lambda x: (x[1], x[0]))

cnt, time_end = 1, sessions[0][1]

for i in range(1, n):
    if sessions[i][0] >= time_end:
        cnt += 1
        time_end = sessions[i][1]
        
print(cnt)
```
